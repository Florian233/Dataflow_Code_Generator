#include "Code_Generation.hpp"
#include "Config/config.h"
#include "Config/debug.h"
#include <string>
#include <fstream>

/* Generate the file Channel.hpp containing the Channel base class, the data channel derived class
 * and if required the control channel derived class that is not carring data explicitly.
 */

std::string data_channel =
	"#pragma once\n\n"
    "template<typename T>\n"
    "class Channel {\n"
    "protected:\n"
    "    volatile size_t read_index{ 0 };\n"
    "    volatile size_t write_index{ 0 };\n"
    "    size_t max_size{ 0 };\n"
    "    volatile bool full{ false };\n"
    "    T* data{ nullptr };\n"
    "\n"
    "    void increment_write_index(void);\n"
    "\n"
    "    void increment_read_index(void);\n"
    "\n"
    "    Channel(size_t max);\n"
    "\n"
    "public:\n"
    "    virtual T read(void) = 0;\n"
    "    virtual void write(T t) = 0;\n"
    "    virtual T preview(size_t offset) = 0;\n"
    "    virtual size_t size(void) = 0;\n"
    "\n"
    "    virtual size_t free(void);\n"
    "\n"
    "    //Following functions are required for OMP, not used otherwise\n"
    "    virtual size_t max(void);\n"
    "\n"
    "    virtual size_t get_read_index(void);\n"
    "\n"
    "    virtual size_t get_write_index(void);\n"
    "\n"
    "    virtual void notify_read(size_t elements) = 0;\n"
    "    virtual void notify_write(size_t elements) = 0;\n"
    "\n"
    "    virtual T* data_ptr(void);\n"
    "};\n"
    "\n"
    "template<typename T>\n"
    "class Data_Channel : public Channel<T> {\n"
    "public:\n"
    "\n"
    "    Data_Channel(size_t max);\n"
    "\n"
    "    T read(void);\n"
    "\n"
    "    void write(T t);\n"
    "\n"
    "    T preview(size_t offset);\n"
    "\n"
    "    size_t size(void);\n"
    "\n"
    "    void notify_read(size_t elements);\n"
    "\n"
    "    void notify_write(size_t elements);\n"
    "};\n"
    "\n"
    "template<typename T>\n"
    "void Channel<T>::increment_write_index(void) {\n"
    "    if (write_index == (max_size - 1)) {\n"
    "        write_index = 0;\n"
    "    }\n"
    "    else {\n"
    "        ++write_index;\n"
    "    }\n"
    "    if (read_index == write_index) {\n"
    "        full = true;\n"
    "    }\n"
    "}\n"
    "\n"
    "template<typename T>\n"
    "void Channel<T>::increment_read_index(void) {\n"
    "    if (read_index == (max_size - 1)) {\n"
    "        read_index = 0;\n"
    "    }\n"
    "    else {\n"
    "        ++read_index;\n"
    "    }\n"
    "    if (full && (read_index != write_index)) {\n"
    "        full = false;\n"
    "    }\n"
    "}\n"
    "\n"
    "template<typename T>\n"
    "Channel<T>::Channel(size_t max) : max_size{ max } {};\n"
    "\n"
    "template<typename T>\n"
    "size_t Channel<T>::free(void) {\n"
    "    return max_size - size();\n"
    "}\n"
    "\n"
    "template<typename T>\n"
    "size_t Channel<T>::max(void) {\n"
    "    return max_size;\n"
    "}\n"
    "\n"
    "template<typename T>\n"
    "size_t Channel<T>::get_read_index(void) {\n"
    "    return read_index;\n"
    "}\n"
    "\n"
    "template<typename T>\n"
    "size_t Channel<T>::get_write_index(void) {\n"
    "    return write_index;\n"
    "}\n"
    "\n"
    "template<typename T>\n"
    "T* Channel<T>::data_ptr(void) {\n"
    "    return data;\n"
    "}\n"
    "\n"
    "template<typename T>\n"
    "Data_Channel<T>::Data_Channel(size_t max) : Channel<T>(max) {\n"
    "    this->data = (T*)malloc(sizeof(T) * max);\n"
    "}\n"
    "\n"
    "template<typename T>\n"
    "T Data_Channel<T>::read(void) {\n"
    "    T element = this->data[this->read_index];\n"
    "    this->increment_read_index();\n"
    "    return element;\n"
    "}\n"
    "\n"
    "template<typename T>\n"
    "void Data_Channel<T>::write(T t) {\n"
    "    this->data[this->write_index] = t;\n"
    "    this->increment_write_index();\n"
    "}\n"
    "\n"
    "template<typename T>\n"
    "T Data_Channel<T>::preview(size_t offset) {\n"
    "    return this->data[(this->read_index + offset) % this->max_size];\n"
    "}\n"
    "\n"
    "template<typename T>\n"
    "size_t Data_Channel<T>::size(void) {\n"
    "    if (this->full) {\n"
    "        return this->max_size;\n"
    "    }\n"
    "    return (this->max_size + this->write_index - this->read_index) % this->max_size;\n"
    "}\n"
    "\n"
    "template<typename T>\n"
    "void Data_Channel<T>::notify_read(size_t elements) {\n"
    "    if (this->read_index >= (this->max_size - elements)) {\n"
    "        this->read_index = (this->read_index + elements) - this->max_size;\n"
    "    }\n"
    "    else {\n"
    "        this->read_index += elements;\n"
    "    }\n"
    "    if (this->full && (this->read_index != this->write_index)) {\n"
    "        this->full = false;\n"
    "    }\n"
    "}\n"
    "\n"
    "template<typename T>\n"
    "void Data_Channel<T>::notify_write(size_t elements) {\n"
    "    if (this->write_index >= (this->max_size - elements)) {\n"
    "        this->write_index = (this->write_index + elements) - this->max_size;\n"
    "    }\n"
    "    else {\n"
    "        this->write_index += elements;\n"
    "    }\n"
    "    if (this->read_index == this->write_index) {\n"
    "        this->full = true; \n"
    "    }\n"
    "}";
    
std::string control_channel =
        "template<typename T>\n"
        "class Control_Channel : public Channel<T> {\n"
        "public:\n"
        "\n"
        "    T read(void);\n"
        "\n"
        "    void write(T t);\n"
        "\n"
        "    T preview(size_t offset);\n"
        "\n"
        "    size_t size(void);\n"
        "\n"
        "    void notify_read(size_t elements);\n"
        "\n"
        "    void notify_write(size_t elements);\n"
        "};\n\n"
        "template<typename T>\n"
        "T Control_Channel<T>::read(void) {\n"
        "    this->increment_read_index();\n"
        "    return static_cast<T>(1);\n"
        "}\n"
        "\n"
        "template<typename T>\n"
        "void Control_Channel<T>::write(T t) {\n"
        "    this->increment_write_index();\n"
        "}\n"
        "\n"
        "template<typename T>\n"
        "T Control_Channel<T>::preview(size_t offset) {\n"
        "    return static_cast<T>(1);\n"
        "}\n"
        "\n"
        "template<typename T>\n"
        "size_t Control_Channel<T>::size(void) {\n"
        "    if (this->full) {\n"
        "        return this->max_size;\n"
        "    }\n"
        "    return (this->max_size + this->write_index - this->read_index) % this->max_size;\n"
        "}\n"
        "\n"
        "template<typename T>\n"
        "void Control_Channel<T>::notify_read(size_t elements) {\n"
        "    if (this->read_index >= (this->max_size - elements)) {\n"
        "        this->read_index = (this->read_index + elements) - this->max_size;\n"
        "    }\n"
        "    else {\n"
        "        this->read_index += elements;\n"
        "    }\n"
        "    if (this->full && (this->read_index != this->write_index)) {\n"
        "        this->full = false;\n"
        "    }\n"
        "}\n"
        "\n"
        "template<typename T>\n"
        "void Control_Channel<T>::notify_write(size_t elements) {\n"
        "    if (this->write_index >= (this->max_size - elements)) {\n"
        "        this->write_index = (this->write_index + elements) - this->max_size;\n"
        "    }\n"
        "    else {\n"
        "        this->write_index += elements;\n"
        "    }\n"
        "    if (this->read_index == this->write_index) {\n"
        "        this->full = true;\n"
        "    }\n"
        "}";


void Code_Generation::generate_channel_code(
	Optimization::Optimization_Data_Phase1* opt_data1,
	Optimization::Optimization_Data_Phase2* opt_data2,
	Mapping::Mapping_Data* map_data)
{
	Config* c = c->getInstance();

	std::string path{ c->get_target_dir() };

	std::ofstream output_file{ path + "\\Channel.hpp"};
	if (output_file.bad()) {
		throw Code_Generation_Exception{ "Cannot open the file " + path + "\\Channel.hpp" };
	}
	output_file << data_channel;

	// only create control channel class if required
	if (opt_data2->control_channel) {
		output_file << "\n\n" << control_channel;
	}

	output_file.close();
}